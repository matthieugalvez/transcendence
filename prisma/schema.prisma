generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./transcendence.db"
}

model User {
  id            String   @id @default(uuid()) // Changed from Int to String with UUID
  email         String   @unique
  displayName   String?
  password_hash String
  provider      String   @default("local")
  refreshToken  String?
  twoFAEnabled  Boolean  @default(false)
  twoFASecret   String?
  avatar        String   @default("/avatars/default.svg")
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  // Friendlist functions
  sentFriendRequests     Friendship[] @relation("UserSentRequests")
  receivedFriendRequests Friendship[] @relation("UserReceivedRequests")

  // User stats
  userStats        UserStats?
  playerOneMatches Match[]    @relation("PlayerOne")
  playerTwoMatches Match[]    @relation("PlayerTwo")

  // Tournament
  tournamentsWon    Tournament[]     @relation("WonTournaments")
  tournamentEntries TournamentUser[]

  @@map("users")
}

model Friendship {
  id         String           @id @default(cuid())
  senderId   String
  receiverId String
  status     FriendshipStatus @default(PENDING)
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt

  sender   User @relation("UserSentRequests", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("UserReceivedRequests", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@map("friendships")
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

model UserStats {
  id     String @id @default(cuid())
  userId String @unique

  oneVOneWins      Int @default(0)
  oneVOneLosses    Int @default(0)
  tournamentWins   Int @default(0)
  tournamentLosses Int @default(0)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_stats")
}

model Match {
  id          String    @id @default(cuid())
  playerOneId String
  playerTwoId String
  winnerId    String?
  matchType   MatchType

  playerOneScore Int @default(0)
  playerTwoScore Int @default(0)

  playedAt DateTime @default(now())

  playerOne User @relation("PlayerOne", fields: [playerOneId], references: [id], onDelete: Cascade)
  playerTwo User @relation("PlayerTwo", fields: [playerTwoId], references: [id], onDelete: Cascade)

  tournamentId String?
  tournament   Tournament? @relation("TournamentMatches", fields: [tournamentId], references: [id], onDelete: Cascade)

  @@map("matches")
}

enum MatchType {
  ONE_V_ONE
  TOURNAMENT
}

model Tournament {
  id           String           @id @default(cuid())
  winnerId     String?
  participants TournamentUser[]
  matches      Match[]          @relation("TournamentMatches")
  winner       User?            @relation("WonTournaments", fields: [winnerId], references: [id])

  playedAt DateTime @default(now())

  @@map("tournaments")
}

model TournamentUser {
  tournament   Tournament @relation(fields: [tournamentId], references: [id])
  tournamentId String
  user         User       @relation(fields: [userId], references: [id])
  userId       String

  rank     Int?
  joinedAt DateTime @default(now())

  @@id([tournamentId, userId])
  @@map("tournament_users")
}

model GameInvite {
  id          String   @id @default(uuid())
  gameId      String
  inviterId   String   // User who sends the invite
  inviteeId   String   // User who receives the invite
  status      String   // 'pending', 'accepted', 'declined', 'expired'
  createdAt   DateTime @default(now())
  expiresAt   DateTime
}
